name: spherecode
run-name: Deploy ${{ inputs.component }} to ${{ inputs.environment }}

on:
  workflow_dispatch:
    inputs:
      component:
        description: Input the component you wish to deploy. Use "fullstack" to deploy the entire app stack.
        required: true
        type: string
      environment:
        description: Select a deployment environment.
        type: choice
        options:
          - dev
          - qa
          - uat
          - prod
          - id
          - standalone
        required: true
      target_environment:
        description: "Input target environment(s) for Prod. For multiple environments input them with comma separated i.e. (env1, env2)"
        type: string
        default: 'All'
        required: false
      keep:
        description: Check to Overwrite the current AppConfig.
        type:  boolean
        required: false
          
permissions:
  contents: read
  id-token: write

jobs:    
  check-component-input:
    environment: ${{ inputs.environment }}
    runs-on: ubuntu-latest
    outputs:
      component: ${{ steps.component-input.outputs.component }}
    steps:
      - name: checkout code
        uses: actions/checkout@v4 
      - name: check component input 
        id: component-input
        shell: bash
        run: |
          temp="${{ inputs.component }}"
          lower=${temp,,}
          if [[ "$lower" == "fullstack" ]]; then
            echo "component=fullstack" >> $GITHUB_OUTPUT
            echo "Deploying fullstack"
          else 
            comp=`jq '.[] | .componentName' component.json | grep -i "\<${{ inputs.component }}\>" -m1`
            lowercomp=${comp,,}
            if [[ $lowercomp == "\"${lower}\"" ]]; then
              echo "Deploying `cat ./component.json | grep -iF -o "${{ inputs.component }}" -m1`"
              echo "component=`cat ./component.json | grep -iF -o "${{ inputs.component }}" -m1`" >> $GITHUB_OUTPUT
            else
              echo "Error: Component '${{ inputs.component }}' not found in component.json"
              exit 1
            fi
          fi
          
  create-environment-matrix:
    needs: check-component-input
    runs-on: ubuntu-latest
    outputs:
        env: ${{ steps.env-matrix.outputs.env }}
    steps:
      - name: checkout code
        uses: actions/checkout@v4  
      - name: get environment input and created matrix
        id: env-matrix
        shell: bash
        run: |
          #Trim the spaces from target environment input.
          input_envs=$(echo "${{ inputs.target_environment }}" | tr -d '[:blank:]')

          if [[ "${{ inputs.environment }}" == "prod" ]]; then
                 #Output all environments
            if [[ "$input_envs" == "All" ]]; then
              echo "env=`cat ./client-manifests/${{ inputs.environment }}-clients.json | jq -c`" >> $GITHUB_OUTPUT
            else
              #Prepare the Environment Json
              deploy_envs="["

              #Convert the input into an array if there are multiple environments
              IFS=',' read -ra ENV_ARRAY <<< "$input_envs"
              for env in "${ENV_ARRAY[@]}"; do
                matching_env=$(jq -c ".[] | select(.env == \"$env\")" ./client-manifests/${{ inputs.environment }}-clients.json)
             
                if [[ -z "$matching_env" ]]; then
                  echo "Error: No matching environment found for '$env' in ${{ inputs.environment }}-clients.json"
                  exit 1
                else
                  # Append the matching environment to the list
                  if [[ -z "$deploy_envs" || "$deploy_envs" == "[" ]]; then
                    deploy_envs="$deploy_envs$matching_env"
                  else
                    deploy_envs="$deploy_envs, $matching_env"
                  fi
                 fi
               done

               # Close the JSON array
               deploy_envs="$deploy_envs]"
               echo "env=$deploy_envs" >> $GITHUB_OUTPUT
              fi
            else
              # If environment is not prod, fetch all environment
              echo "env=`cat ./client-manifests/${{ inputs.environment }}-clients.json | jq -c`" >> $GITHUB_OUTPUT
             fi  
   
  
  set-environment-runner:
    runs-on: ubuntu-latest
    outputs:
      runner: ${{ steps.env-runner.outputs.runner }}
    steps:
      - name: set runner group
        id: env-runner
        run: |
          if [[ ${{ inputs.environment }} == "prod" ]]; then
            echo "runner=Prod" >> $GITHUB_OUTPUT
          else
            echo "runner=NonProd" >> $GITHUB_OUTPUT
          fi
  call-phase:
     needs: [check-component-input, create-environment-matrix]
     uses: ./.github/workflows/deploy-phase.yml
     with: 
      component: ${{ inputs.component }}
      environment: ${{ inputs.environment }}
      runner: ${{ inputs.runner }}

  report-job-status:
    needs: [check-component-input, create-environment-matrix, set-environment-runner, call-phase]
    runs-on: ubuntu-latest
    outputs:
       OverallPhaseJobStatus: ${{ steps.report-status.outputs.OverallPhaseJobStatus }}
       ComponentJobStatusPhase1: ${{ steps.report-status.outputs.ComponentJobStatusPhase1 }}
       ComponentJobStatusPhase2: ${{ steps.report-status.outputs.ComponentJobStatusPhase2 }}
       ComponentJobStatusPhase3: ${{ steps.report-status.outputs.ComponentJobStatusPhase3 }}
    steps:
      - name: Report job statuses
        id: report-status
        run: |
         run: |
          # Collect controller job statuses
          controller-job-status="job1 status: ${{ needs.check-component-input.result }}, "
          controller-job-status+="job2 status: ${{ needs.create-environment-matrix.result }}, "
          controller-job-status+="job3 status: ${{ needs.set-environment-runner.result }}"

          # Print controller job statuses (for debugging)
          echo "ControllerJobStatus:"
          echo "$controller-job-status" | tr ',' '\n' | sed 's/^ *//;s/ *$//'

          # Extract and format phase job statuses
          overall-phase-job-status="${{ needs.call-phase.outputs.phase-status }}"
          component-job-status-phase-1="${{ needs.call-phase.outputs.comp-status-phase1 }}" | tr ',' '\n' | sed 's/^ *//;s/ *$//'
          component-job-status-phase-2="${{ needs.call-phase.outputs.comp-status-phase2 }}" | tr ',' '\n' | sed 's/^ *//;s/ *$//'
          component-job-status-phase-3="${{ needs.call-phase.outputs.comp-status-phase3 }}" | tr ',' '\n' | sed 's/^ *//;s/ *$//'

          # Sanitize outputs for GitHub Actions
          sanitized_overall_phase_status=$(echo "$overall-phase-job-status" | sed 's/[[:cntrl:]]//g')
          sanitized_phase1_status=$(echo "$component-job-status-phase-1" | sed 's/[[:cntrl:]]//g')
          sanitized_phase2_status=$(echo "$component-job-status-phase-2" | sed 's/[[:cntrl:]]//g')
          sanitized_phase3_status=$(echo "$component-job-status-phase-3" | sed 's/[[:cntrl:]]//g')

          # Output sanitized statuses to GitHub Actions
          echo "overall-phase-job-status=${sanitized_overall_phase_status}" >> $GITHUB_OUTPUT
          echo "component-job-status-phase-1=${sanitized_phase1_status}" >> $GITHUB_OUTPUT
          echo "component-job-status-phase-2=${sanitized_phase2_status}" >> $GITHUB_OUTPUT
          echo "component-job-status-phase-3=${sanitized_phase3_status}" >> $GITHUB_OUTPUT

  use-job-status:
    needs: report-job-status
    runs-on: ubuntu-latest
    steps:
      - name: Use Job Status Outputs
        run: |
          echo "OverallPhaseJobStatus: ${{ needs.report-job-status.outputs.OverallPhaseJobStatus }}"
          echo "ComponentJobStatus for Phase 1: ${{ needs.report-job-status.outputs.ComponentJobStatus-for-Phase1 }}"
          echo "ComponentJobStatus for Phase 2: ${{ needs.report-job-status.outputs.ComponentJobStatus-for-Phase2 }}"
          echo "ComponentJobStatus for Phase 3: ${{ needs.report-job-status.outputs.ComponentJobStatus-for-Phase3 }}"
