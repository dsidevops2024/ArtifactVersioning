name: Deploy Component New
on:
  workflow_dispatch:
    inputs:
      component:
        description: Input the component you wish to deploy. Use "fullstack" to deploy the entire app stack.
        required: true
        type: string
      environment:
        description: Select a deployment environment.
        type: choice
        options:
          - dev
          - qa
          - uat
          - prod
          - id
          - standalone
        required: true
      target_environment:
        description: "Input target environment(s) for Prod. For multiple environments input them with comma separated i.e. (env1, env2)"
        type: string
        default: 'All'
        required: false
      keep:
        description: Check to Overwrite the current AppConfig.
        type:  boolean
        required: false
          
permissions:
  contents: read
  id-token: write
  #workflow_call:
    #inputs:
      #component:
        #type: string
        #required: true
      #environment:
        #type: string
        #required: true
      #runner:
        #type: string
        #required: true
    #outputs:        
      #compstatus:
        #value: ${{ jobs.component-status.outputs.output1 }}
    
jobs:
  create-component-matrix:
    runs-on: ubuntu-latest
    steps:
      - name: Job 1 step
        id: step1
        run: |
          echo "firstword=job1 from deploy component" 

  deploy-to-AzService:
    runs-on: ubuntu-latest
    needs: create-component-matrix
    steps:
      - name: Job 2 step
        id: step2  # We add an ID for job2
        run: |
          echo "secondword=job2 from deploy component" 
  
  component-status:
    runs-on: ubuntu-latest
    needs: [create-component-matrix, deploy-to-AzService]
    outputs:
      output1: ${{ steps.report-status.outputs.compjob }}
    steps:
      - name: Report job statuses
        id: report-status
        run: |
          # Create an empty string to store all job statuses
          compjob=""

          # Loop through each job dynamically using `toJSON` (or manually in the script for each job)
          job_statuses='{"create-component-matrix": "${{ needs.create-component-matrix.result }}", "deploy-to-AzService": "${{ needs.deploy-to-AzService.result }}"}'

          # Dynamically build the compjob string
          compjob=$(echo $job_statuses | jq -r 'to_entries | map("\(.key) status: \(.value)") | join(", ")')

          # Output the concatenated job status
          echo "compjob=$compjob" 
          ##>> $GITHUB_OUTPUT
