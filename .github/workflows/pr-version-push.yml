name: calculate-version

on:
  push:
    branches: [main]

jobs:
  calculate-version:
    runs-on: ubuntu-latest
    outputs:
      version_json: ${{ steps.bump_json.outputs.updated_json }}
      components: ${{ steps.components.outputs.components }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Authenticate GitHub CLI
        run: |
           gh auth login --with-token <<< "${{ secrets.AVPAT_TOKEN }}"

      - name: Get merged PR info
        id: pr
        env:
          GITHUB_TOKEN: ${{ secrets.AVPAT_TOKEN }}
        run: |
          PR_JSON=$(gh pr list --state merged --limit 20 --json number,mergeCommit,baseRefName,headRefName,labels,mergeCommit \
            --jq ".[] | select(.mergeCommit.oid == \"${{ github.sha }}\")")
          
          echo "$PR_JSON" > pr.json
          
          PR_NUMBER=$(jq -r '.number' pr.json)
          BASE_REF=$(jq -r '.baseRefName' pr.json)
          HEAD_REF=$(jq -r '.headRefName' pr.json)
          
          echo "PR_NUMBER=$PR_NUMBER" >> $GITHUB_ENV
          echo "BASE_REF=$BASE_REF" >> $GITHUB_ENV
          echo "HEAD_REF=$HEAD_REF" >> $GITHUB_ENV

      - name: Get PR labels
        id: labels
        run: |
          LABELS=$(jq -r '.labels[].name' pr.json)
          echo "Labels: $LABELS"
          TYPE=""

          if echo "$LABELS" | grep -q 'semver:major'; then
            TYPE="major"
          elif echo "$LABELS" | grep -q 'semver:minor'; then
            TYPE="minor"
          elif echo "$LABELS" | grep -q 'semver:patch'; then
            TYPE="patch"
          else
            echo "❌ No valid semver label found."
            exit 1
          fi
          echo "type=$TYPE" >> $GITHUB_OUTPUT

      - name: Detect changed components
        id: components
        run: |
          git fetch origin main
          FILES=$(git diff --name-only HEAD^1 HEAD)

          echo "$FILES"
          {
            echo 'files<<EOF'
            echo "$FILES"
            echo 'EOF'
          } >> "$GITHUB_OUTPUT"

          COMPONENTS_FROM_YML=$(echo "$FILES" | grep -oP 'ci-\K[^.]+(?=\.yml)' || true)
          COMPONENTS_FROM_DIR=$(echo "$FILES" | awk -F/ '$1 != ".github" && $1 != "backend" { print $1 }' | sort -u || true)
          COMPONENTS=$(echo -e "$COMPONENTS_FROM_YML\n$COMPONENTS_FROM_DIR" | sort -u | tr '\n' ' ')
          
          BACKEND_FILES=$(echo "$FILES" | grep '^backend/' || true)
          if [ -n "$BACKEND_FILES" ]; then
            COMPONENTS_JSON="backend/backend-components.json"
            if ! jq empty "$COMPONENTS_JSON"; then
              echo "❌ Invalid JSON in $COMPONENTS_JSON"
              exit 1
            fi

            declare -A MATCHED_BACKEND_COMPONENTS=()
            while IFS= read -r file; do
              TITLES=$(jq -r '.[].title' "$COMPONENTS_JSON")
              for title in $TITLES; do
                if [[ "$file" == *"$title"* ]]; then
                  MATCHED_BACKEND_COMPONENTS["$title"]=1
                fi
              done
            done <<< "$FILES"

            BACKEND_COMPONENTS=$(printf "%s\n" "${!MATCHED_BACKEND_COMPONENTS[@]}" | sort -u | tr '\n' ' ')
            if [ -n "$BACKEND_COMPONENTS" ]; then
              COMPONENTS="$COMPONENTS $BACKEND_COMPONENTS"
            fi
          fi

          COMPONENTS=$(echo "$COMPONENTS" | xargs -n1 | sort -u | tr '\n' ' ')
          if [[ -z "$COMPONENTS" ]]; then
            echo "⚠️ No components changed. Exiting."
            exit 1
          fi
          echo "Detected components: $COMPONENTS"
          echo "components=$COMPONENTS" >> $GITHUB_OUTPUT
          
          #git fetch origin $BASE_REF $HEAD_REF
          #BASE=$(git merge-base origin/$BASE_REF origin/$HEAD_REF)
          #FILES=$(git diff --name-only $BASE origin/$HEAD_REF)

          #echo "$FILES"
          #{
            #echo 'files<<EOF'
            #echo "$FILES"
            #echo 'EOF'
          #} >> "$GITHUB_OUTPUT"

          #COMPONENTS_FROM_YML=$(echo "$FILES" | grep -oP 'ci-\K[^.]+(?=\.yml)' || true)
          #COMPONENTS_FROM_DIR=$(echo "$FILES" | awk -F/ '$1 != ".github" && $1 != "backend" { print $1 }' | sort -u || true)
          #COMPONENTS=$(echo -e "$COMPONENTS_FROM_YML\n$COMPONENTS_FROM_DIR" | sort -u | tr '\n' ' ')
          #echo "Detected components: $COMPONENTS"
          #echo "components=$COMPONENTS" >> $GITHUB_OUTPUT

      - name: Bump version JSON
        id: bump_json
        run: |
          echo '${{ vars.JSON_VERSIONS }}' > versions.json
          cp versions.json tmp.json
          BUMP_TYPE="${{ steps.labels.outputs.type }}"
          COMPONENTS="${{ steps.components.outputs.components }}"

          for COMP in $COMPONENTS; do
            CURRENT=$(jq -r --arg c "$COMP" '.[$c]' tmp.json)
            [[ "$CURRENT" == "null" ]] && continue
            IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT"
            case "$BUMP_TYPE" in
              major) ((MAJOR+=1)); MINOR=0; PATCH=0 ;;
              minor) ((MINOR+=1)); PATCH=0 ;;
              patch) ((PATCH+=1)) ;;
            esac
            NEW="$MAJOR.$MINOR.$PATCH"
            jq --arg c "$COMP" --arg v "$NEW" '.[$c]=$v' tmp.json > tmp2.json && mv tmp2.json tmp.json
          done

          FINAL=$(jq -c . tmp.json)
          echo "$FINAL" > version.json
          echo "updated_json=$FINAL"
          echo "updated_json=$FINAL" >> $GITHUB_OUTPUT

      - name: Upload version.json
        uses: actions/upload-artifact@v4
        with:
          name: version-info
          path: version.json
