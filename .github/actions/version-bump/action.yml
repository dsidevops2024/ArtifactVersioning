name: 'Calculate Artifact Versions'
description: 'Detect changed components, semver label, and bump version'

inputs:
  github-token:
    description: 'GitHub Token'
    required: true
  json-versions:
    description: 'JSON_VERSIONS org variable value'
    required: true

outputs:
  version_json:
    description: 'Updated version JSON'
    value: ${{ steps.bump_json.outputs.updated_json }}
  components:
    description: 'List of changed components'
    value: ${{ steps.components.outputs.components }}

runs:
  using: "composite"
  steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
    # Install GitHub CLI if not present
    #- name: Install GitHub CLI
      #shell: powershell
      #run: |
        #choco install gh

    # Add GitHub CLI to PATH (if needed)
    #- name: Add GitHub CLI to PATH
      #shell: powershell
      #run: |
        #$env:PATH += ";`"C:\Program Files\GitHub CLI`""
        #Write-Host "GH CLI is available on PATH: $env:PATH"

    # Verify if GH CLI is available
    #- name: Verify GitHub CLI installation
      #shell: powershell
      #run: |
        #gh --version
        
    - name: Add GitHub CLI to PATH
      shell: powershell
      run: |
        $env:Path += ";C:\Program Files\GitHub CLI"
        #$env:path += ";`"C:\Program Files\GitHub CLI`""
        Write-Host "GH CLI is available on PATH: $env:PATH"
        gh --version

    - name: Authenticate GitHub CLI
      shell: powershell
      run: |
        "${{ inputs.github-token }}" | gh auth login --with-token

    - name: Get merged PR info
      id: pr
      shell: powershell
      env:
        GITHUB_TOKEN: ${{ inputs.github-token }}
      run: |
        $sha = "${{ github.sha }}"
        $pr = gh pr list --state merged --limit 20 --json number,mergeCommit,baseRefName,headRefName,labels,mergeCommit |
          ConvertFrom-Json |
          Where-Object { $_.mergeCommit.oid -eq $sha }

        $pr | ConvertTo-Json -Depth 10 | Out-File -FilePath pr.json -Encoding UTF8

        "PR_NUMBER=$($pr.number)" | Out-File -FilePath $env:GITHUB_ENV -Append
        "BASE_REF=$($pr.baseRefName)" | Out-File -FilePath $env:GITHUB_ENV -Append
        "HEAD_REF=$($pr.headRefName)" | Out-File -FilePath $env:GITHUB_ENV -Append

    - name: Get PR labels
      id: labels
      shell: powershell
      run: |
        $labels = (Get-Content -Raw pr.json | ConvertFrom-Json).labels.name
        $type = ""
        if ($labels -contains "semver:major") {
          $type = "major"
        } elseif ($labels -contains "semver:minor") {
          $type = "minor"
        } elseif ($labels -contains "semver:patch") {
          $type = "patch"
        } else {
          Write-Error "No valid semver label found."
          exit 1
        }
        Write-Host "‚úÖ Version bump type: $type"
        "type=$type" | Out-File -FilePath $env:GITHUB_OUTPUT -Append

    - name: Detect changed components
      id: components
      shell: powershell
      run: |
        git fetch origin main
        $files = git diff --name-only HEAD^1 HEAD
        Write-Host "Changed files:"
        $files

        # Extract component names from ci-*.yml files
        $componentsFromYml = @()
        $componentsFromYml += $files | Where-Object { $_ -match 'ci-(.+)\.yml' } | ForEach-Object {
          ($_ -split 'ci-')[1] -replace '\.yml', ''
        }
        Write-Host "üîπ Components from YML: $($componentsFromYml -join ', ')"

        # Extract top-level directories, excluding .github and backend
        $componentsFromDir = @()
        $componentsFromDir += $files | ForEach-Object {
          ($_.Split('/')[0])
        } | Where-Object { $_ -and ($_ -ne ".github") -and ($_ -ne "backend") }
        Write-Host "üîπ Components from directories: $($componentsFromDir -join ', ')"

        # Combine initial components
        $components = @()
        $components += $componentsFromYml
        $components += $componentsFromDir

        # Handle backend components if changed
        $backendFiles = $files | Where-Object { $_ -like 'backend/*' }
        if ($backendFiles.Count -gt 0) {
          $jsonFile = "backend/backend-components.json"
          try {
            $backendJson = Get-Content $jsonFile | ConvertFrom-Json
          } catch {
            Write-Error "‚ùå Invalid JSON in $jsonFile"
            exit 1
          }

          $matchedBackend = @()
          foreach ($file in $files) {
            foreach ($item in $backendJson) {
              if ($file -like "*$($item.title)*") {
                $matchedBackend += $item.title
              }
            }
          }

          if ($matchedBackend.Count -gt 0) {
            Write-Host "üîπ Matched backend components: $($matchedBackend -join ', ')"
            $components += $matchedBackend
          }
        }

        # Final cleanup: remove empty values, "backend", and duplicates
        $components = $components | Where-Object { $_ -and ($_ -ne "backend") } | Select-Object -Unique

        if (-not $components -or $components.Count -eq 0) {
          Write-Error "‚ùå No components changed. Exiting."
          exit 1
        }

        Write-Host "üß© Parsed components before join: $($components -join ', ')"
        $componentStr = $components -join " "
        Write-Host "‚úÖ Final component string: '$componentStr'"

        "components=$componentStr" | Out-File -FilePath $env:GITHUB_OUTPUT -Append   
        
    - name: Bump version JSON
      id: bump_json
      shell: powershell
      run: |
        # Load input JSON
        $versionsJson = '${{ inputs.json-versions }}' | ConvertFrom-Json

        # Clone the object safely by serializing and deserializing
        $tmpJson = $versionsJson | ConvertTo-Json -Depth 10 | ConvertFrom-Json

        $bumpType = "${{ steps.labels.outputs.type }}"
        #$components = "${{ steps.components.outputs.components }}" -split '\s+'
        $components = "${{ steps.components.outputs.components }}" -split '\s+' | Where-Object { $_ -ne "" }
        Write-Host "üß© Parsed components: $($components -join ', ')"

        foreach ($comp in $components) {
          # Check if property exists on object
          if (-not $tmpJson.PSObject.Properties.Name -contains $comp) { continue }

            $current = $tmpJson.$comp
            $parts = $current -split '\.'
            [int]$major = $parts[0]
            [int]$minor = $parts[1]
            [int]$patch = $parts[2]

            switch ($bumpType) {
              "major" { $major++; $minor = 0; $patch = 0 }
              "minor" { $minor++; $patch = 0 }
              "patch" { $patch++ }
            }

            $newVersion = "$major.$minor.$patch"
            # Update the property value
            $tmpJson | Add-Member -NotePropertyName $comp -NotePropertyValue $newVersion -Force
          }

          $finalJson = $tmpJson | ConvertTo-Json -Compress
          $finalJson | Out-File -FilePath version.json -Encoding utf8
          "updated_json=$finalJson" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
