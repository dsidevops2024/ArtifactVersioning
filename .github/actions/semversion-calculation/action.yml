name: 'Calculate Component Versions'
description: 'Detect changed components, semver label, and bump version'
inputs:
  github-token:
    description: 'GitHub Token'
    required: true
  json-versions:
    description: 'JSON_VERSIONS org variable value'
    required: true
outputs:
  version_json:
    description: 'Updated version JSON'
    value: ${{ steps.bump_json.outputs.updated_json }}
  components:
    description: 'List of changed components'
    value: ${{ steps.components.outputs.components }}
runs:
  using: "composite"
  steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Authenticate GitHub CLI
      shell: bash
      run: gh auth login --with-token <<< "${{ inputs.github-token }}"

    - name: Get merged PR info
      id: pr
      shell: bash
      env:
        GITHUB_TOKEN: ${{ inputs.github-token }}
      run: |
        PR_JSON=$(gh pr list --state merged --limit 20 --json number,mergeCommit,baseRefName,headRefName,labels,mergeCommit \
          --jq ".[] | select(.mergeCommit.oid == \"${{ github.sha }}\")")

        echo "$PR_JSON" > pr.json

        echo "PR_NUMBER=$(jq -r '.number' pr.json)" >> $GITHUB_ENV
        echo "BASE_REF=$(jq -r '.baseRefName' pr.json)" >> $GITHUB_ENV
        echo "HEAD_REF=$(jq -r '.headRefName' pr.json)" >> $GITHUB_ENV

    - name: Get PR labels
      id: labels
      shell: bash
      run: |
        LABELS=$(jq -r '.labels[].name' pr.json)
        TYPE=""

        if echo "$LABELS" | grep -q 'semver:major'; then
          TYPE="major"
        elif echo "$LABELS" | grep -q 'semver:minor'; then
          TYPE="minor"
        elif echo "$LABELS" | grep -q 'semver:patch'; then
          TYPE="patch"
        else
          echo "❌ No valid semver label found."
          exit 1
        fi
        echo "type=$TYPE" 
        echo "type=$TYPE" >> $GITHUB_OUTPUT

    - name: Detect changed components
      id: components
      shell: pwsh
      run: |
        git fetch origin main
        FILES=$(git diff --name-only HEAD^1 HEAD)
        #FILES=$(git diff --name-only origin/main...HEAD)
        echo "$FILES"

        # Extract component names from ci-*.yml files (case-insensitive)
        $componentsFromYml = $files | Where-Object { $_ -match '(?i)ci-(.+)\.yml' } | ForEach-Object {
          ($_ -split 'ci-')[1] -replace '\.yml', ''
        }

        # Extract top-level directories (skip .github and backend)
        $componentsFromDir = $files | ForEach-Object {
          ($_.Split('/')[0])
        } | Where-Object { $_ -and ($_ -ne ".github") -and ($_ -ne "backend") }

        $components = @()
        $components += $componentsFromYml
        $components += $componentsFromDir

        # Handle backend components
        $backendFiles = $files | Where-Object { $_ -like 'backend/*' }
        if ($backendFiles.Count -gt 0) {
          $jsonFile = "backend/backend-components.json"
          try {
            $backendJson = Get-Content $jsonFile | ConvertFrom-Json
          } catch {
            Write-Error "Invalid JSON in $jsonFile"
            exit 1
          }

          $matchedBackend = @()
          foreach ($file in $files) {
            foreach ($item in $backendJson) {
              if ($file -like "*$($item.title)*") {
                $matchedBackend += $item.title
              }
            }
          }

          $components += $matchedBackend
        }

        # Clean: remove empty, "backend", and duplicates
        $components = $components | Where-Object { $_ -and ($_ -ne "backend") } | Sort-Object -Unique

        if (-not $components) {
          Write-Error "No components changed. Exiting."
          exit 1
        }

        Write-Host "🧩 Parsed components before join: $($components -join ', ')"
        $componentStr = ($components -join ' ')
        Write-Host "✅ Final component string: '$componentStr'"

        "components=$componentStr" | Out-File -FilePath $env:GITHUB_OUTPUT -Append

    - name: Bump version JSON
      id: bump_json
      shell: bash
      run: |
        echo '${{ inputs.json-versions }}' | jq . > versions.json 
        cp versions.json tmp.json

        BUMP_TYPE="${{ steps.labels.outputs.type }}"
        COMPONENTS="${{ steps.components.outputs.components }}"

        for COMP in $COMPONENTS; do
          CURRENT=$(jq -r --arg c "$COMP" '.[$c]' tmp.json)
          [[ "$CURRENT" == "null" ]] && continue
          IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT"
          case "$BUMP_TYPE" in
            major) ((MAJOR+=1)); MINOR=0; PATCH=0 ;;
            minor) ((MINOR+=1)); PATCH=0 ;;
            patch) ((PATCH+=1)) ;;
          esac
          NEW="$MAJOR.$MINOR.$PATCH"
          jq --arg c "$COMP" --arg v "$NEW" '.[$c]=$v' tmp.json > tmp2.json && mv tmp2.json tmp.json
        done

        FINAL=$(jq -c . tmp.json)
        echo "$FINAL" > version.json
        echo "updated_json=$FINAL" >> $GITHUB_OUTPUT

    #- name: Upload version.json
      #uses: actions/upload-artifact@v4
      #with:
       # name: version-info
        #path: version.json
